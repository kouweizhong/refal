
/*-------------------------------------------------------------------------*/
/*	Trying to create LL(1) parser for Refal ;)                              */
/*	Y [11-06-06]                                                            */
/*-------------------------------------------------------------------------*/

using System.Collections;
using System.CodeDom;

COMPILER Refal

/*-------------------------------------------------------------------------*/
/*	LL(1) conflict resolvers                                                */
/*-------------------------------------------------------------------------*/

	static bool IsSentence()
	{
		Scanner.ResetPeek();
		Token tok = Scanner.Peek();
		return la.kind == _Semicolon && tok.kind != _RBrace;
	}

/*-------------------------------------------------------------------------*/
/*	AST built by compiler                                                   */
/*-------------------------------------------------------------------------*/

	static CodeBuilder cb = new CodeBuilder();
	public static Program Program
	{
		get { return cb.Program; }
	}

/*-------------------------------------------------------------------------*/
/* scanner and parser                                                      */
/*-------------------------------------------------------------------------*/

CHARACTERS
	
	Letter     = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".
	Digit      = "0123456789".
	Cr         = '\r'.
	Lf         = '\n'.
	Tab        = '\t'.
	Space      = ' '.
	StringChar = ANY - '"' - '\\'.
	CharChar   = ANY - '\'' - '\\' - Cr - Lf.
	Printable  = '\u0020' .. '\u007e'.
	HexDigit   = "0123456789abcdefABCDEF".

TOKENS
	
	Identifier = ['@'] Letter { Letter | Digit | "-" | "_" }.
	String     = '"' { StringChar | '\\' Printable { HexDigit } } '"'.
	Character  = '\'' { CharChar | '\\' Printable { HexDigit } } '\''.
	
	Integer    = ( Digit { Digit } | ("0x" | "0X") HexDigit { HexDigit } )
		[ ( "U" | "u" [ "L" | "l" ] ) | ("L" | "l" [ "U" | "u" ] ) ] .
	
	Real      =
		"." Digit { Digit }
		[ ( "E" | "e" ) [ "+" | "-" ] Digit { Digit } ]
		[ "F" | "f" | "D" | "d" | "M" | "m" ]
		| Digit { Digit }
		  ( "." Digit { Digit }
		    [ ( "E" | "e" ) [ "+" | "-" ] Digit { Digit } ]
		    [ "F" | "f" | "D" | "d" | "M" | "m" ]
		  | ( "E" | "e" ) [ "+" | "-" ] Digit { Digit }
		    [ "F" | "f" | "D" | "d" | "M" | "m" ]
		  | "F" | "f" | "D" | "d" | "M" | "m" ) .
		
	Equal = "=" .

	Bool       = "bool" .
	Char       = "char" .
	Float      = "float" .
	Int        = "int" .
	Null       = "null" .
	Object     = "object" .
	Str        = "str" .
	True       = "True" .
	False      = "False" .
	Else       = "else" .
	Entry      = "$ENTRY" .
	Extern     = "$EXTRN" | "$EXTERN" | "$EXTERNAL" .
	Semicolon  = ";" .
	LBracket   = "[" .
	LParen     = "(" .
	LBrace     = "{" .
	LEval      = "<" .
	RBracket   = "]" .
	RParen     = ")" .
	RBrace     = "}" .
	REval      = ">" .

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "*" TO Cr 
COMMENTS FROM "*" TO Lf

IGNORE Cr + Lf + Tab

PRODUCTIONS

/*-------------------------------------------------------------------------*/

Refal = Definition { Definition } .

Definition = Function | External .

External =
	Extern
	Identifier                                   (. cb.AddExternalFunction(t.val); .)
	{ "," Identifier                             (. cb.AddExternalFunction(t.val); .)
	} ";" .

Function =                                      (. cb.BeginFunction(); Block block; .)
	[ Entry                                      (. cb.SetEntryPoint(); .)
	] Identifier                                 (. cb.SetFunctionName(t.val); .)
	Block<out block> [ ";" ]                     (. cb.EndFunction(block); .)
	.

Block<out Block block> =                        (. block = cb.BeginBlock(); .)
	"{"
		Sentence
		{ IF (IsSentence()) ";" Sentence }
		[ ";" ]
	"}"                                          (. cb.EndBlock(); .)
	.

Sentence =                                      (. cb.BeginSentence(); .)
	Pattern
	( "=" Expression
	| WhereOrWithClause
	)                                            (. cb.EndSentence(); .)
	.

Pattern =                                       (. cb.BeginPattern(); .)
	{ Variable
	| Literal
	| "(" Pattern ")"
	}                                            (. cb.EndPattern(); .)
	.

WhereOrWithClause =                             (. Block block; .)
	( "," | "&" ) Expression ":"
	( Block<out block> /* with-clause */
	| Pattern /* where-clause */
		( "=" Expression
		| WhereOrWithClause
		)
	) .

Expression = { Call | Variable | Literal | "(" Expression ")" } .

Variable = ( "e." | "s." | "t." ) ( Integer | Identifier ) .

Literal = String | Character | Integer | True | False | Identifier .

Call = "<" Identifier Expression ">" .

/*-------------------------------------------------------------------------*/

END Refal.
