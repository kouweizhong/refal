
/*-------------------------------------------------------------------------*/
/*	Trying to create LL(1) parser for Refal ;)                              */
/*	Y [11-06-06]                                                            */
/*-------------------------------------------------------------------------*/

using System.Collections;
using System.CodeDom;

COMPILER Refal

/*-------------------------------------------------------------------------*/
/*	LL(1) conflict resolvers                                                */
/*-------------------------------------------------------------------------*/

	static bool IsSentence()
	{
		Scanner.ResetPeek();
		Token tok = Scanner.Peek();
		return la.kind == _Semicolon && tok.kind != _RBrace;
	}

/*-------------------------------------------------------------------------*/
/*	AST built by compiler                                                   */
/*-------------------------------------------------------------------------*/

	static CodeBuilder cb = new CodeBuilder();
	public static Program Program
	{
		get { return cb.Program; }
	}

/*-------------------------------------------------------------------------*/
/* scanner and parser                                                      */
/*-------------------------------------------------------------------------*/

CHARACTERS
	
	Letter     = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".
	Digit      = "0123456789".
	Cr         = '\r'.
	Lf         = '\n'.
	Tab        = '\t'.
	Space      = ' '.
	StringChar = ANY - '"' - '\\'.
	CharChar   = ANY - '\'' - '\\' - Cr - Lf.
	Printable  = '\u0020' .. '\u007e'.
	HexDigit   = "0123456789abcdefABCDEF".

TOKENS
	
	Identifier = ['@'] Letter { Letter | Digit | "-" | "_" }.
	String     = '"' { StringChar | '\\' Printable { HexDigit } } '"'.
	Character  = '\'' { CharChar | '\\' Printable { HexDigit } } '\''.
	
	Integer    = ( Digit { Digit } | ("0x" | "0X") HexDigit { HexDigit } )
		[ ( "U" | "u" [ "L" | "l" ] ) | ("L" | "l" [ "U" | "u" ] ) ] .
	
	Real      =
		"." Digit { Digit }
		[ ( "E" | "e" ) [ "+" | "-" ] Digit { Digit } ]
		[ "F" | "f" | "D" | "d" | "M" | "m" ]
		| Digit { Digit }
		  ( "." Digit { Digit }
		    [ ( "E" | "e" ) [ "+" | "-" ] Digit { Digit } ]
		    [ "F" | "f" | "D" | "d" | "M" | "m" ]
		  | ( "E" | "e" ) [ "+" | "-" ] Digit { Digit }
		    [ "F" | "f" | "D" | "d" | "M" | "m" ]
		  | "F" | "f" | "D" | "d" | "M" | "m" ) .
		
	Equal = "=" .

	Bool       = "bool" .
	Char       = "char" .
	Float      = "float" .
	Int        = "int" .
	Null       = "null" .
	Object     = "object" .
	Str        = "str" .
	True       = "True" .
	False      = "False" .
	Else       = "else" .
	Entry      = "$ENTRY" .
	Extern     = "$EXTRN" | "$EXTERN" | "$EXTERNAL" .
	Semicolon  = ";" .
	LBracket   = "[" .
	LParen     = "(" .
	LBrace     = "{" .
	LEval      = "<" .
	RBracket   = "]" .
	RParen     = ")" .
	RBrace     = "}" .
	REval      = ">" .

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "*" TO Cr 
COMMENTS FROM "*" TO Lf

IGNORE Cr + Lf + Tab

PRODUCTIONS

/*-------------------------------------------------------------------------*/

Refal = Definition { Definition } .

Definition = Function | External .

External =
	Extern
	Identifier                                   (. cb.AddExternalFunction(t.val); .)
	{ "," Identifier                             (. cb.AddExternalFunction(t.val); .)
	} ";" .

Function =                                      (. cb.BeginFunction(); Block block; .)
	[ Entry                                      (. cb.SetEntryPoint(); .)
	] Identifier                                 (. cb.SetFunctionName(t.val); .)
	Block<out block> [ ";" ]                     (. cb.EndFunction(block); .)
	.

Block<out Block block> =                        (. block = cb.BeginBlock(); .)
	"{"
		Sentence
		{ IF (IsSentence()) ";" Sentence }
		[ ";" ]
	"}"                                          (. cb.EndBlock(); .)
	.

Sentence =                                      (. cb.BeginSentence();
                                                   Pattern pattern; .)
	Pattern<out pattern>
	( "=" Expression
	| WhereOrWithClause
	)                                            (. cb.EndSentence(); .)
	.

Pattern<out Pattern pattern> =                  (. pattern = cb.BeginPattern(); 
                                                   Variable variable;
                                                   Symbol symbol;
                                                   Pattern innerPattern; .)
	{ Variable<out variable>                     (. pattern.Terms.Add(variable); .)
	| Symbol<out symbol>
	| "(" Pattern<out innerPattern> ")"          (. pattern.Terms.Add(new PatternInParentheses(innerPattern)); .)
	}                                            (. cb.EndPattern(); .)
	.

WhereOrWithClause =                             (. Block block; Pattern pattern; .)
	( "," | "&" ) Expression ":"
	( Block<out block> /* with-clause */
	| Pattern<out pattern> /* where-clause */
		( "=" Expression
		| WhereOrWithClause
		)
	) .

Expression =                                    (. Variable variable; 
                                                   Symbol symbol; .)
	{ Call
	| Variable<out variable>
	| Symbol<out symbol>
	| "(" Expression ")" 
	} .

Variable<out Variable variable> =               (. variable = new UnknownVariable(); .)
	( "e."                                       (. variable = new ExpressionVariable(); .)
	| "s."                                       (. variable = new SymbolVariable(); .)
	| "t."                                       (. variable = new TermVariable(); .)
	)
	( Integer | Identifier )                     (. variable.Index = t.val; .)
	.

Symbol<out Symbol symbol> =                     (. symbol = null; .)
	( String                                     (. symbol = new CompoundSymbol(t.val); .)
	| Character                                  (. symbol = new Character(t.val); .)
	| Integer                                    (. symbol = new Macrodigit(Convert.ToInt32(t.val)); .)
	| True                                       (. symbol = new TrueIdentifier(t.val); .)
	| False                                      (. symbol = new FalseIdentifier(t.val); .)
	| Identifier                                 (. symbol = new Identifier(t.val); .)
	) .

Call = "<" Identifier Expression ">" .

/*-------------------------------------------------------------------------*/

END Refal.
